# This is my study notes from a 42 project called Inception.

AULA 01:
	O que são contêineres? Não são VMs.
        Os contêineres são sinônimos de ISOLAMENTO. 
        Isto é, podemos isolar um contêiner e seus processos 
        próprios  de forma que ele não consiga ser acessado 
        por outro contêiner. Dessa forma, não temos conflitos.

	Conseguimos, também, limitar / especificar quais recursos 
    este contêiner específico vai poder acessar. 

    Temos dois tipos de isolamento:
    - Isolamento lógico: Parte dos “softwares”, 
            isto é, parte não hardware. “Rede, usuário, 
            processos e etc”

    - Isolamento físico: Parte dos hardware. 
            Memória, CPU e etc. “CPU, memória, disco e etc”

    Então, de forma resumida, CONTEINERES são nada mais 
    nada menos que uma forma de isolar nossos recursos.

    Docker não é um contêiner. Ele apenas é uma ferramenta 
    que auxilia na manipulação dos contêineres.

=======================================================================================
=======================================================================================

AULA 02: 
    Imagens de container: É, basicamente uma cópia de um serviço
    para nosso container. 

    Copy on write: 

    Ainda não entendi muito bem como funciona esses conceitos.

=======================================================================================
=======================================================================================

AULA 03:
    Os CONTEINERES compartilham o mesmo kernel linux. Isto
    é, eles compartilham o mesmo SO do host.

    Então é como se pegássemos um pc e isolarmos diversas
    pequenas partes desse pc para rodarmos serviços
    diferentes usando o mesmo kernel linux do host.

    Totalmente diferente da forma como as VMs funcionam.
    As VMs possuem um SO que roda em cima de outro SO,
    do host, que através de um hipervisor, gerencia o
    compartilhamento de recursos para ambos.
    
    BASICAMENTE: Quando temos um CONTEINER ele não possue
    um SO com um kernel próprio em execução. Ele usa o 
    kernel do próprio host, isto é, do servidor linux.

NETFILTER / IPTABLE:
    São os responsáveis para gerenciar e redirecionar
    os acessos de fora para os respectivos CONTEINERES
    que estão rodando o serviço.

NAMESPACES: ??

=======================================================================================
=======================================================================================

AULA 04 / 05:
    Primeiro precisamos ter um VM para conseguir instalar
    tudo que o docker precisa. Estou usando uma VM com
    o Debian.

    Logo em seguida, precisamos instalar o docker em si.
    Link para documentação: https://docs.docker.com/engine/install/
    Nesse link, basta selecionar o SO que você deseja e 
    seguir os passos para instalar.

    Comando usado pelo LinuxTips: *NAO FIZ ASSIM*
        @@ curl -fsSL https://get.docker.com | bash

    Caso queiramos usar o Docker ser estarmos no root, podemos
    adicionar o nosso user no grupo docker com o seguinte 
    comando:
        @@ sudo usermod -aG docker <seu_user>

=======================================================================================
=======================================================================================

"De maneira resumida, o docker funciona da seguinte forma: 
quando rodamos o docker container run -ti hello-world, 
o Docker client fala pro Docker daemon começar os trabalhos.
Em seguida o Docker daemon baixa a imagem do hello-world, 
caso ela não exista no host, ou executa ela, caso ela já
exista no host.
Então, o Docker daemon cria um novo container a partir da
imagem que do hello-world. 
O DOCKER CLIENT SE COMUNICA COM O DOCKER DEAMON..."

AULA 06:
    Comando usado para ver quais CONTEINERES estão rodando:
       @@  docker ps
            -> Versão antiga do comando
       @@  docker container ls
            -> Versão nova do comando
    
    Comando para fazer um hello world no docker:
        @@ docker container run -ti hello-world
            -> A flag -ti indica que vou querer ter um terminal
            para que eu possa ter uma interatividade com esse 
            container que vai ser executado. 
                Então, quando esse container subir, eu já vou
            estar conectado à ele.

    Comando para ver quais containers estão em execução
    e os que foram executados:
        @@ docker container ls -a

    Comando para teste:
        @@ docker container run -ti ubuntu
            -> Nesse caso, vamos rodar um container com uma
            imagem do ubuntu latest.
            -> Assim que rodarmos o comando, teremos acesso
            a esse container pelo terminal.
            -> Apretando ctrl+D, matamos o ENTRYPOINT do
            container.
            -> Quando matamos o ENTRYPOINT, o ubuntu entende que,
            não existindo um ENTRYPOINT para o container, pode
            matar o container.

    ENTRYPOINT:
        É o principal processo do container.

    Para sairmos do terminal do container, isto é, do ENTRYPOINT
    do container, digitamos o seguinte comando:
       @@ ctrl+P+Q
        -> Esse comando vai fazer com que saiamos do 
        ENTRYPOINT do container mas não mate o container
        em execução.
        -> Então, se executarmos o comando,
        docker container ls
        Veremos que o container ainda estará em execução.

    Para acessarmos o ENTRYPOINT do container em execução usamos
    o comando: 
        @@ docker container attach <id_container> OU <nome_container>
        
    Comando para teste:
        @@ docker container run -ti nginx
            -> Caso não tenhamos uma imagem do NGINX ele vai baixar.
            -> Se já tivermos uma imagem do NGINX, ele só vai executa-la.
            OBS: O container do NGINX não possui um ENTRYPOINT bash.
                Só conseguimos acessa-lo através do seu processo
                TODO PROCESSO QUE ESTÁ EM EXECUÇÃO DENTRO DE UM CONTEINER
                ELE PRECISA ESTAR EM FOREGROUND, ISTO É, EM PRIMEIRO PLANO!

        @@ docker container run -d nginx
            -> Nesse caso, estamos indicando que o container com a
            imagem do nginx vai ser executada como deamon.
            -> Porém, ainda assim, não conseguimos ter acesso ao ENTRYPOINT
            bash dele. Pois o nginx não tem.

        Em casos assim, temos que usar um comando EXEC.
        @@ docker container exec -ti <id_container> <comando>
            -> O exec -ti vai executar um comando via terminal dentro do
            processo do container escolhido...
            OBS: Por isso que, no labs, precisavamos usar aquele comando
            gigantesco "docker compose exec api poetry run ..."
                -> pois o container que estava rodando nossa aplicação
                não tinha um ENTRYPOINT bash para acessarmos ele.

    O QUE É RODAR ALGO COMO DEAMON? USANDO A FLAG -d
        É fazer com que algo não rode no foreground, isto é, em primeiro
        plano.
        Geralmente todos os nossos containeres serão executados
        usando a flag -d. Pois eles não terão necessidade de um ENTRYPOINT
        bash. Dessa forma, não travando o nosso terminal.

=======================================================================================
=======================================================================================

AULA 07:
    Para pararmos a execução de um container, usamos o seguinte
    comando:
        @@ docker container stop <id_container> OU <nome_container>

    Para iniciarmos a execução de um container, usamos o seguinte
    comando:
        @@ docker container start <id_container> OU <nome_container>
    
    Para restartarmos um container, usamos o seguinte comando:
        @@ docker container restart <id_container> OU <nome_container>
    
    Para pausarmos a excução de um container, usamos o seguinte comando:
        @@ docker container pause <id_container> OU <nome_container>

    Para despausarmos um container, usamos o seguinte comando:
        @@ docker container unpause <id_container> OU <nome_container>

    Para vermos TODAS as informações de um determinado container, 
    usamos o seguinte comando:
        @@ docker container inspect <id_container> OU <nome_container>
            -> Parece que retorna um JSON com diversas informações 
            sobre o container especificado.

    Para vermos o LOG de um container, usamos o seguinte comando:
        @@ docker container logs -f <id_container> OU <nome_container>
            -> A flag -f é de FORCE

    Para matarmos a execução de um container, usamos o seguinte comando:
        @@ docker container rm <id_container> OU <nome_container>
            -> Não podemos remover um container que está em execução.
            A menos que usemos a flag -f.
    
    Podemos também remover os containeres que já não estão mais em execução.
    Isto é, que já foram STOPADOS.
        @@ docker container ls -a
            -> veremos todos os containeres que estão ou estiveram em execução
        @@ docker container rm <id_container>
            -> vamos remover o container indicado pelo id dele.

=======================================================================================
=======================================================================================

AULA 08:
    Para visualizarmos as estatísticas do container em execução, usamos
    o seguinte comando:
        @@ docker container stats <id_container> OU <nome_container>
            -> Ele vai nos informar sobre os recursos que nosso container
            está utilizando. Isto é, CPU, memória, I/O de rede e disco
            e etc.
    
    Podemos ver quais são os processos sendo executados dentro do nosso
    container usando o seguinte comando:
        @@ docker container top <id_container> OU <nome_container>
            -> Traz as informações de todos os processos que estão em 
            execução dentro do container.
    
    Podemos usar, depois de instalarmos, um comando chamado stress. Ele
    pode ser usado para estressar nossos containeres com a finalidade de
    testa-los.
        @@ stress *VER DEPOIS*
            -> executar "docker container exec -ti <id_container> bash"
            -> executar "apt-get update && apt-get install -y stress"

    FLAG -m ao rodar uma imagem de NGINX:
        @@ docker container run -d -m 128M nginx
            -> A flag -m é de --memory, que serve para indicar a quantidade
            de memória que este container vai utilizar.
    FLAG --cpus ao rodar uma imagem de NGINX:
        @@ docker container run -d --cpus 0.5 nginx
            -> A flag --cpus indica quanto de CPU no máximo vamos destinar
            a este container específico.

    Para darmos update em um container em execução, usamos o seguinte
    comando:
        @@ docker container update --cpus 0.2 <id_container>
            -> A ideia aqui é atualizar recursos do nosso container
            especifico. No caso do exemplo, estamos reduzindo o 
            consumo de CPU do container X.
            -> Podemos usar outras FLAGS para indicar que recurso
            queremos atualizar. -m para memory e etc...

=======================================================================================
=======================================================================================

AULA 09:
    Para vermos as imagens que utilizamos em nossos containeres, 
    usamos o seguinte comando:
        @@ docker image ls
            -> Ele lista todas as imagens já utilizadas por nossos
            containeres.

    Para criarmos uma imagem customizada, temos que criar um Dockerfile.
    Exemplo de Dockerfile nos arquivos.
        -> Um ponto importante é que, quando colocamos o comando RUN
        dentro do Dockerfile, esse comando vai ser executado em tempo
        de BUILD da imagem.
        -> Quando temos um comando CMD, este só vai ser executado em
        tempo de execução do container. Isto é, só vai ser executado
        quando subirmos o container com a imgaem já buildada.

    Para BUILDARMOS uma imagem, temos o seguinte comando:
        @@ docker image build -t <nome_imagem>

    Para SUBIRMOS o container, temos o seguinte comando:
        @@ docker container run -d <nome_imagem>


=======================================================================================
=======================================================================================
