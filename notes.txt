# This is my study notes from a 42 project called Inception.

=======================================================================================
=======================================================================================
                                        DAY 01
=======================================================================================
=======================================================================================

AULA 01:
	O que são contêineres? Não são VMs.
        Os contêineres são sinônimos de ISOLAMENTO. 
        Isto é, podemos isolar um contêiner e seus processos 
        próprios  de forma que ele não consiga ser acessado 
        por outro contêiner. Dessa forma, não temos conflitos.

	Conseguimos, também, limitar / especificar quais recursos 
    este contêiner específico vai poder acessar. 

    Temos dois tipos de isolamento:
    - Isolamento lógico: Parte dos “softwares”, 
            isto é, parte não hardware. “Rede, usuário, 
            processos e etc”

    - Isolamento físico: Parte dos hardware. 
            Memória, CPU e etc. “CPU, memória, disco e etc”

    Então, de forma resumida, CONTEINERES são nada mais 
    nada menos que uma forma de isolar nossos recursos.

    Docker não é um contêiner. Ele apenas é uma ferramenta 
    que auxilia na manipulação dos contêineres.

=======================================================================================
=======================================================================================

AULA 02: 
    Imagens de container: É, basicamente uma cópia de um serviço
    para nosso container. 

    Copy on write: 

    Ainda não entendi muito bem como funciona esses conceitos.

=======================================================================================
=======================================================================================

AULA 03:
    Os CONTEINERES compartilham o mesmo kernel linux. Isto
    é, eles compartilham o mesmo SO do host.

    Então é como se pegássemos um pc e isolarmos diversas
    pequenas partes desse pc para rodarmos serviços
    diferentes usando o mesmo kernel linux do host.

    Totalmente diferente da forma como as VMs funcionam.
    As VMs possuem um SO que roda em cima de outro SO,
    do host, que através de um hipervisor, gerencia o
    compartilhamento de recursos para ambos.
    
    BASICAMENTE: Quando temos um CONTEINER ele não possue
    um SO com um kernel próprio em execução. Ele usa o 
    kernel do próprio host, isto é, do servidor linux.

NETFILTER / IPTABLE:
    São os responsáveis para gerenciar e redirecionar
    os acessos de fora para os respectivos CONTEINERES
    que estão rodando o serviço.

NAMESPACES: ??

=======================================================================================
=======================================================================================

AULA 04 / 05:
    Primeiro precisamos ter um VM para conseguir instalar
    tudo que o docker precisa. Estou usando uma VM com
    o Debian.

    Logo em seguida, precisamos instalar o docker em si.
    Link para documentação: https://docs.docker.com/engine/install/
    Nesse link, basta selecionar o SO que você deseja e 
    seguir os passos para instalar.

    Comando usado pelo LinuxTips: *NAO FIZ ASSIM*
        @@ curl -fsSL https://get.docker.com | bash

    Caso queiramos usar o Docker ser estarmos no root, podemos
    adicionar o nosso user no grupo docker com o seguinte 
    comando:
        @@ sudo usermod -aG docker <seu_user>

=======================================================================================
=======================================================================================

"De maneira resumida, o docker funciona da seguinte forma: 
quando rodamos o docker container run -ti hello-world, 
o Docker client fala pro Docker daemon começar os trabalhos.
Em seguida o Docker daemon baixa a imagem do hello-world, 
caso ela não exista no host, ou executa ela, caso ela já
exista no host.
Então, o Docker daemon cria um novo container a partir da
imagem que do hello-world. 
O DOCKER CLIENT SE COMUNICA COM O DOCKER DEAMON..."

AULA 06:
    Comando usado para ver quais CONTEINERES estão rodando:
       @@  docker ps
            -> Versão antiga do comando
       @@  docker container ls
            -> Versão nova do comando
    
    Comando para fazer um hello world no docker:
        @@ docker container run -ti hello-world
            -> A flag -ti indica que vou querer ter um terminal
            para que eu possa ter uma interatividade com esse 
            container que vai ser executado. 
                Então, quando esse container subir, eu já vou
            estar conectado à ele.

    Comando para ver quais containers estão em execução
    e os que foram executados:
        @@ docker container ls -a

    Comando para teste:
        @@ docker container run -ti ubuntu
            -> Nesse caso, vamos rodar um container com uma
            imagem do ubuntu latest.
            -> Assim que rodarmos o comando, teremos acesso
            a esse container pelo terminal.
            -> Apretando ctrl+D, matamos o ENTRYPOINT do
            container.
            -> Quando matamos o ENTRYPOINT, o ubuntu entende que,
            não existindo um ENTRYPOINT para o container, pode
            matar o container.

    ENTRYPOINT:
        É o principal processo do container.

    Para sairmos do terminal do container, isto é, do ENTRYPOINT
    do container, digitamos o seguinte comando:
       @@ ctrl+P+Q
        -> Esse comando vai fazer com que saiamos do 
        ENTRYPOINT do container mas não mate o container
        em execução.
        -> Então, se executarmos o comando,
        docker container ls
        Veremos que o container ainda estará em execução.

    Para acessarmos o ENTRYPOINT do container em execução usamos
    o comando: 
        @@ docker container attach <id_container> OU <nome_container>
        
    Comando para teste:
        @@ docker container run -ti nginx
            -> Caso não tenhamos uma imagem do NGINX ele vai baixar.
            -> Se já tivermos uma imagem do NGINX, ele só vai executa-la.
            OBS: O container do NGINX não possui um ENTRYPOINT bash.
                Só conseguimos acessa-lo através do seu processo
                TODO PROCESSO QUE ESTÁ EM EXECUÇÃO DENTRO DE UM CONTEINER
                ELE PRECISA ESTAR EM FOREGROUND, ISTO É, EM PRIMEIRO PLANO!

        @@ docker container run -d nginx
            -> Nesse caso, estamos indicando que o container com a
            imagem do nginx vai ser executada como deamon.
            -> Porém, ainda assim, não conseguimos ter acesso ao ENTRYPOINT
            bash dele. Pois o nginx não tem.

        Em casos assim, temos que usar um comando EXEC.
        @@ docker container exec -ti <id_container> <comando>
            -> O exec -ti vai executar um comando via terminal dentro do
            processo do container escolhido...
            OBS: Por isso que, no labs, precisavamos usar aquele comando
            gigantesco "docker compose exec api poetry run ..."
                -> pois o container que estava rodando nossa aplicação
                não tinha um ENTRYPOINT bash para acessarmos ele.

    O QUE É RODAR ALGO COMO DEAMON? USANDO A FLAG -d
        É fazer com que algo não rode no foreground, isto é, em primeiro
        plano.
        Geralmente todos os nossos containeres serão executados
        usando a flag -d. Pois eles não terão necessidade de um ENTRYPOINT
        bash. Dessa forma, não travando o nosso terminal.

=======================================================================================
=======================================================================================

AULA 07:
    Para pararmos a execução de um container, usamos o seguinte
    comando:
        @@ docker container stop <id_container> OU <nome_container>

    Para iniciarmos a execução de um container, usamos o seguinte
    comando:
        @@ docker container start <id_container> OU <nome_container>
    
    Para restartarmos um container, usamos o seguinte comando:
        @@ docker container restart <id_container> OU <nome_container>
    
    Para pausarmos a excução de um container, usamos o seguinte comando:
        @@ docker container pause <id_container> OU <nome_container>

    Para despausarmos um container, usamos o seguinte comando:
        @@ docker container unpause <id_container> OU <nome_container>

    Para vermos TODAS as informações de um determinado container, 
    usamos o seguinte comando:
        @@ docker container inspect <id_container> OU <nome_container>
            -> Parece que retorna um JSON com diversas informações 
            sobre o container especificado.

    Para vermos o LOG de um container, usamos o seguinte comando:
        @@ docker container logs -f <id_container> OU <nome_container>
            -> A flag -f é de FORCE

    Para matarmos a execução de um container, usamos o seguinte comando:
        @@ docker container rm <id_container> OU <nome_container>
            -> Não podemos remover um container que está em execução.
            A menos que usemos a flag -f.
    
    Podemos também remover os containeres que já não estão mais em execução.
    Isto é, que já foram STOPADOS.
        @@ docker container ls -a
            -> veremos todos os containeres que estão ou estiveram em execução
        @@ docker container rm <id_container>
            -> vamos remover o container indicado pelo id dele.

=======================================================================================
=======================================================================================

AULA 08:
    Para visualizarmos as estatísticas do container em execução, usamos
    o seguinte comando:
        @@ docker container stats <id_container> OU <nome_container>
            -> Ele vai nos informar sobre os recursos que nosso container
            está utilizando. Isto é, CPU, memória, I/O de rede e disco
            e etc.
    
    Podemos ver quais são os processos sendo executados dentro do nosso
    container usando o seguinte comando:
        @@ docker container top <id_container> OU <nome_container>
            -> Traz as informações de todos os processos que estão em 
            execução dentro do container.
    
    Podemos usar, depois de instalarmos, um comando chamado stress. Ele
    pode ser usado para estressar nossos containeres com a finalidade de
    testa-los.
        @@ stress *VER DEPOIS*
            -> executar "docker container exec -ti <id_container> bash"
            -> executar "apt-get update && apt-get install -y stress"
        @@ stress --cpu 1 --vm-bytes 128M --vm 1
            -> Com esse comando, vamos estressar o container.
            -> Vamos usar 100% da CPU, 128M da memória

    FLAG -m ao rodar uma imagem de NGINX:
        @@ docker container run -d -m 128M nginx
            -> A flag -m é de --memory, que serve para indicar a quantidade
            de memória que este container vai utilizar.
    FLAG --cpus ao rodar uma imagem de NGINX:
        @@ docker container run -d --cpus 0.5 nginx
            -> A flag --cpus indica quanto de CPU no máximo vamos destinar
            a este container específico.

    Para darmos update em um container em execução, usamos o seguinte
    comando:
        @@ docker container update --cpus 0.2 <id_container>
            -> A ideia aqui é atualizar recursos do nosso container
            especifico. No caso do exemplo, estamos reduzindo o 
            consumo de CPU do container X.
            -> Podemos usar outras FLAGS para indicar que recurso
            queremos atualizar. -m para memory e etc...

=======================================================================================
=======================================================================================

AULA 09:
    Para vermos as imagens que utilizamos em nossos containeres, 
    usamos o seguinte comando:
        @@ docker image ls
            -> Ele lista todas as imagens já utilizadas por nossos
            containeres.

    Para criarmos uma imagem customizada, temos que criar um Dockerfile.
    Exemplo de Dockerfile nos arquivos.
        -> Um ponto importante é que, quando colocamos o comando RUN
        dentro do Dockerfile, esse comando vai ser executado em tempo
        de BUILD da imagem.
        -> Quando temos um comando CMD, este só vai ser executado em
        tempo de execução do container. Isto é, só vai ser executado
        quando subirmos o container com a imgaem já buildada.

    Para BUILDARMOS uma imagem, temos o seguinte comando:
        @@ docker image build -t <nome_imagem>

    Para SUBIRMOS o container, temos o seguinte comando:
        @@ docker container run -d <nome_imagem>

=======================================================================================
=======================================================================================
                                        DAY 02
=======================================================================================
=======================================================================================

AULA 02:
    "Sempre que matamos um container, isto é, ele deixa de estar rodando,
    nós perdemos todas as informações e dados que ele possuía."

    VOLUMES: "Os volumes são uma forma de persistir os dados dos containeres.
        Isto é, se um container cair, por qualquer motivo, os dados e 
        informações contidas nele vão ser armazenadas no VOLUME."

            "Dessa maneira, ao subirmos um novo container com a mesma
        imagem do container anterior, ele vai usar os dados e informações
        contidas no VOLUME. Não perdendo, dessa forma, os dados e informações."
    
            "BASICAMENTE, é uma forma de colocar um filesystem dentro de um
        container."

        TEMOS DOIS TIPOS DE VOLUMES:
            BIND: 
                    -> É quando temos um diretório que já possui informações e dados
                    que nós queremos, e a partir dele, queremos subir um novo
                    container.
                    -> Então nós já possuimos um diretório e queremos que o novo
                    container seja montado em cima desse diretório.

                @@ docker container run -ti --mount type=bind,src=/path/dir,dst=/dir <nome_imagem>
                    -> --mount: FLAG usada para indicar algo na montagem do 
                            container
                    -> type=bind: indicando qual o tipo de volume vai ser 
                            usado na montagem do container
                    -> ,src=path: indicando qual o diretório que será usado como
                            base na montagem do container
                    -> ,dst=dir: onde esse container será montado.
            VOLUME:
    
=======================================================================================
=======================================================================================

AULA 03:
    "Na hora de montarmos e subirmos um container, podemos indicar que ele
    vai ser usado apenas como READ ONLY. Isto é, poderá ser usado apenas
    para leitura."

    TODO VOLUME DO TIPO VOLUME VAI ESTAR NO SEGUINTE DIRETÓRIO:
    /var/lib/docker/volumes/...
        -> ... vai ser o nome do dir que você criou.
        -> podemos acessa-lo e manipular os arquivos

    @@ docker container run --mount type=bind,src...,dst...,ro nginx
        -> O 'ro' está indicando que o container será apenas READ ONLY

    Podemos manipular os VOLUMES do tipo VOLUME da seguinte maneira:
    @@ docker volume ls
    @@ docker volume create <nome_volume>
        -> para criarmos um novo volume
    @@ docker volume inspect <nome_volume>
        -> para inspecionarmos as informações do volume especifico
    @@ docker volume rm <nome_volume>
        -> para deletarmos um volume especifico

    Para subirmos um novo container usando o VOLUME do tipo VOLUME,
    podemos usar o seguinte comando:
    @@ docker container run -ti --mount type=volume,src=<nome_volume>,dst=... <nome_imagem>
        -> O typo de volume agora é volume
        -> O src vai ser o novo volume que acabamos de criar, não precisamos
        passar o path completo, apenas o nome já basta.
        -> o dst vai ser onde ele vai montar dentro do container
    
    Podemos ter mais de um container usando o mesmo volume.
    Na hora de remover o volume, precisamos tomar cuidado com os
    containeres que estão usando nosso volume.

=======================================================================================
=======================================================================================

AULA 04:
    "Quando montamos e subimos um container usando algum tipo de volume,
    ele fica especificado no container. Isto é, se dermos inspect nesse
    container especifico, conseguimos identificar varias informações do
    volume selecionado na montagem do container."

    @@ docker volume ls
        -> Para vermos os volumes do tipo volume ja criados e disponiveis.
    @@ docker volume create <nome_volume>
        -> Para criarmos um novo volume do tipo volume
    @@ docker container run -ti --mount type=volume,src=/<nome_volume>,dst=<nome_volume> <nome_imagem>
        -> Subimos um novo container usando o volume especificado.
    @@ docker container inspect <nome_container>
        -> Conseguimos ver várias informações sobre o container,
        inclusive o volume que foi usado na montagem do container.

    @@ docker volume prune
        -> Comando usado para apagar todos os volumes que não
        estão sendo utilizados por pelo menos 1 container.
    @@ docker container prune
        -> Comando usado para apagar todos os containeres que não
        estão rodando.
        -> Então, ele apaga somente os containers que já não
        sendo usados. Isto é, os que não estão rodando.
    
    @@ docker image prune
        -> Ele apaga todas as imagens que estão "bagunçadas".

    PRUNE:
        "Pelo que parece, ele é um comando usado para apagar tudo
        que não está sendo usado atualmente. Isso vai para os containeres,
        volumes, images e etc..."

        "É muito importante tomar cuidado na hora de remover, principalmente
        os volumes, ao usar o PRUNE. Pois, caso removamos um volume que não
        está sendo usado no momento, mas contia algum tipo de informação
        importante, estas informações foram perdidas."

        "O container e/ou as imagens, não tem tanto problema quanto os volumes."
    
=======================================================================================
=======================================================================================

AULA 05:
    "Descriçaõ do desafio está no arquivo ToTest.txt, tópico 6."

AULA 06:
    "Minha solução e a solução correta estão lá tbm."

=======================================================================================
=======================================================================================

AULA 07:
    "Backup de algum volume ou de algum banco de dados."
    "Não achei o vídeo muito interessante. Basicamente ele apenas
    falou sobre backup usando um VOLUME do tipo BIND. Pelo que vi
    no PDF da inception, não precisa fazer backup de nada. Por conta
    disso, vou deixar pra outra hora esse tópico de backup."

=======================================================================================
=======================================================================================

AULA 08:
    "Muito importante tomar cuidado com as Imagens que já estão publicadas.
    Isto é, as Imagens que alguem disponibilizou no Dockerhub. Porque existe
    uma grande chance delas terem algum tipo de problma com CVEs. Ou seja,
    vulnerabilidades..."

    "Por conta deste problema, o ideal é nós mesmos montemos nossas proprias
    Imagens customizadas. Fazemos isso usando um arquivo Dockerfile."

    DOCKERFILES.
        FROM:
            "Indica qual Imagem vamos nos basear para buildar e 
            subir esse novo container."
            ex: 
                FROM debian

        RUN:
            "Indica quais comandos serão executados em momento
            de BUILD. Isto é, comandos que serão executados na
            hora que estamos BUILDANDO o nosso container novo."

            "Precisamos tomar cuidado com os RUN do Dockerfile.
            Pois eles funcionam em camadas na hora do BUILD, isto é,
            mesmo que os comandos sejam executados de maneira correta,
            uma camada não vai se comunicar com outra camada."
            ex:
                RUN apt-get update && apt-get install -y apache2 ...
                    -> O && indica que vamos executar mais de um comando.
                    -> O -y indica que vamos dar yes nas opções, pois
                    não podemos digitar nada na hora do build.

        ENV:
            "Forma como criamos variáveis de ambiente dentro do nosso
            container."
            ex:
                ENV USER="aprado"

            "IMPORTANTE: Alguns serviços que vamos usar vão precisar de
            algumas ENVs específicas. Sempre podemos achar essas 
            informações na documentação do serviço especifico."

        LABEL:
            "É basicamente uma tag que podemos colocar no container.
            Pode ser, de certa forma, qualquer coisa no formato KEY=VALUE."
            ex:
                LABEL version="1.0"

        VOLUME:
            "Local onde o docker vai montar um novo volume do tipo volume
            para o container que está sendo buildado no momento."

            "Sempre que rola um build o docker cria um novo volume para
            esse novo container. Pelo que eu entendi, esse cara é apenas
            para indicar o local onde esse volume ficara armazenado."
            ex:
                VOLUME /var/www/html/

        EXPOSE:
            "Estamos dizendo para o docker que a porta 80 estará em
            exposta."

            "É uma forma mais simples de explicitar para o docker que a 
            porta 80 precisa ser usada e exposta no container."
            @@ docker container run -ti -P
                -> O -P indica que ele vai olhar no Dockerfile se existe 
                alguma tag EXPOSE.
                -> Caso exista, ele vai atribuir em alguma porta aleatória do host.
                O que não é legal.
            ex:
                EXPOSE 80

=======================================================================================
=======================================================================================

AULA 09:
    
    @@ docker image build -t <nome_imagem> .
        -> Usamos esse comando para buildar uma imagem e podermos
        criar uma instancia dela. Isto é, criar um container.
        -> A FLAG -t é para colocarmos uma TAG nesse build. Deixando
        mais fácil de identifica-lo.
    
    @@ docker container run -ti <nome_imagem>
        -> Usamos para criar um container, isto é, uma instancia
        de uma imagem.

    Dentro do DOCKERFILE, não precisamos mais do seguinte comando:
        RUN ... && apt-get clean
            -> Basicamente esse comando fazia uma limpa do cache
            na hora de criar o container.
            -> Porém, pelos meus testes, não se faz mais necessario.

    OUTRO DETALHE IMPORTANTE, Nesse dockerfile, não estamos rodando o
    webserver apache. Por conta disso, mesmo que alteremos a porta
    do container com a flag -p, não conseguiremos acessar o container.

=======================================================================================
=======================================================================================

AULA 10:
        Quando fazemos o build de uma imagem, estamos prontos para 
    subir e instanciar um novo container usando aquela imagem como
    base.
        Quando damos o build em uma Dockefile que usa algo que já temos
    em cache, o BUILD acaba sendo mais rápido.

    @@ docker image build -t <nome_imagem> .
        -> Comando usado para buildar uma nova imagem.
        -> A FLAG -t é para termos um nome para esse build
    
    @@ docker image build -t <nome_imagem> . --no-cache
        -> A FLAG -t é para termos um nome para esse build
        -> A FLAG --no-cache indica que queremos buildar
        sem usar a layers que estão no cache.

=======================================================================================
=======================================================================================

AULA 11:
    Podemos usar uma TAG dentro do Dockerfile chamada COPY, que vai
    copiar um arquivo em um diretório X para outro diretório Y.

    Usamos essa TAG para nos auxiliar a importar todos os arquivos
    necessários para o nosso container rodar da maneira que desejamos.

    Dentro do Dockerfile:
        FROM debian
        ...
        COPY index.html <novo_dir>
        ...

            -> O arquivo index.html, nesse caso, vai precisar estar
            no mesmo diretório do Dockerfile.

        Temos a opção de usar a TAG ADD:
            -> Ela também, assim como o COPY, copia o arquivo específicado
            para dentro do diretório especificado.
            -> Mas, se o arquivo estiver compactado, ele joga apenas o 
            conteúdo já descompactado.
            -> Ele também consegue pegar um arquivo que esteja na internet.

        Usando a TAG USER:
            -> Com essa TAG nós estamos dizendo que, na hora do build,
            vamos mudar o USER que estará executando algo.

        Usando a TAG WORKDIR:
            -> Essa tag é muito usada pois ela deixa o diretório X
            como base ao nós acessarmos o container em execução.
            Isto é, quando acessarmos o container com o seguinte
            comando:
                @@ docker container exec -ti <nome_container> bash
            -> vamos cair direto nesse WORKDIR.

=======================================================================================
=======================================================================================

AULA 13:
    A ideia dessa aula era subir criar um novo Dockerfile usando golang
    como base.

    Após o build, vamos subir um container usando essa imagem com golang.

    Faremos um arquivo em go para printar "Hello" no terminal.

    Por algum motivo que eu não consegui resolver, não funcionou de maneira
    nenhuma. Deixei pra lá, pois eu entendi o que deveria acontecer
    e como chegar nesse resultado. Enfim. Bola pra frente!

=======================================================================================
=======================================================================================

AULA 14:
    Conceito de Multi stage build é basicamente um tipo de pipeline com builds.

    Isto é, dentro de um Dockerfile, estamos usando um build já existente
    para executar algo e pegar esse algo para usar em outra parte do meu
    build novo.

    É como se fosse assim:
        Primeira parte do Dockerfile é feito para criar a pizza toda, mas
        sem assar e deixa-la pronta para consumo.

        A segunda parte é pegar essa massa pronta e por para assar.

        Então, a segunda parte do build, isto é o ÚLTIMO FROM do Dockerfile,
        apenas pegou o ALGO que foi gerado por um outro build.

    O conceito de multi-stage build (ou "construção em múltiplas etapas") 
    para containers, especialmente no contexto do Docker, é uma técnica 
    usada para otimizar a construção de imagens, separando o processo de 
    build do ambiente de execução final. Ele ajuda a criar imagens menores, 
    mais seguras e eficientes, contendo apenas o necessário para a aplicação rodar.

    "Use a oficina pesada só para fabricar. Depois, leve apenas o necessário 
    para o ambiente de produção."

    Assim, você economiza espaço, ganha velocidade e mantém tudo mais seguro.

=======================================================================================
=======================================================================================

AULA 15:
    Dentro do Dockerfile, podemos executar um comando RUN. Para que esse
    comando fique organizado, isto é, não fique tudo na mesma linha,
    podemos usar o '\'. Dessa forma:
        RUN apt-get update -y && \
            yum install -y apache2 \
            git \
            java \
            python
                -> Dessa forma evitamos da linha ficar gigangtesca
                apt-get update && ... && ... && ...
    
    Dentro de uma IMAGEM devemos colocar APENAS PACOTES NECESSÁRIOS!!!!

    Sempre limpem a CASA com o apt-get clean.
        -> Hoje em dia não se faz tão necessário mais. O próprio
        container já limpa por padrão mesmo com o apt-get clean.
    
    Reduza o número de camadas.
    Use o RUN com moderação.

    Use o .Dockerignore
        -> Funciona da mesma forma que o .gitignore
        -> Precisa estar no mesmo nível do Dockerfile!!
    
    Adicione um NON-ROOT USER.

    ENTENDA:
        CMD:
            CMD ["comando 1", "param", "param", ...]    -> Modo EXEC
            CMD comando1 param param                    -> Modo SHELL

            -> Serve para executarmos comandos.
        
        ENTRYPOINT:
            ENTRYPOINT ["comando 1", "param", ...]
            ENTRYPOINT comando1 param

            -> É o principal processo dentro da execução do container.
            -> Usamos ele para executar alguma coisa depois que o container
            subir.

        Posso usar os dois dentro do mesmo Dockerfile. Porém, caso o faça,
        o CMD será apenas um PARAMETRO do comando executado no ENTRYPOINT.

            ENTRYPOINT ["comando1"]
            CMD ["param"]
                -> Se estou usando os dois, preciso usar o modo EXEC

    CAHCE?
        @@ docker image build --no-cache -t opa:1.0
            -> Não vai usar as layers que estão em cahce.
            -> Isto é, vai buida-las novamente.
        @@ docker image build -t opa:2.0
            -> Vai usar as layers que estão em cache.
            -> Dependendo do caso, pode dar algum problema
            caso o build usado seja mais antigo por exemplo.

        -> É bom usar mas é preciso tomar cuidado quando usar.

    O CONTAINER É IMUTÁVEL E EFÊMERO:
        Efêmero significa: "temporário, que pode ser destruído e recriado 
        a qualquer momento".
            -> Toda vez que você reinicia um container ele volta ao
            estado original da imagem, a menos que você monte ele
            com um volume específico.

        Imutável significa: "não pode ser alterado".
            -> Dessa forma, uma vez que você suba um container com
            uma imagem específica, ele vai ser uma instancia dessa imagem.
            -> A imagem do Docker nao muda. a menos que você mude o
            Dockerfile. Porém, caso o faça, sera outra imagem.
            -> Isso gera uma constância. Pois ela SEMPRE será a mesma!
    
    PODEMOS CRIAR VARIÁVEIS DE AMBIENTE:
        ENV USER=aprado
        ENV APP_DIR=/opt/app
        WORKDIR ${APP_DIR}
        ADD . $APP_DIR
            -> Estamos definindo Variaveis de ambientes e usando-as

    LABELS:
        LABEL version="1:0"
        LABEL description="Podemos usar \
                multi lines."

        -> São atributos CHAVE=VALOR.
        -> Podemos definir várias coisas usando LABELS

    COPY ou ADD:
        Eles fazem basicamente as mesmas coisas, porém com alguns
        detalhes diferentes.
        COPY:
            COPY . /opt/app
            COPY file /dir
            COPY ../dir/file /opt/app
                -> Copia arquivos e diretórios para outro lugar.
            
            ADD . /opt/app
            ADD opa.tar /app
            ADD http://abc.com/file /app
                -> Copia arquivos e diretórios para outro lugar.
                -> Faz a descompactação de arquivos compactados .tar/.targz
                -> Pegar arquivos de lugares remotos, isto é, de links
                e etc...

    ARGS:
        FROM debian
        ARG CONT_IMG_VER
        ENV CONT_IMG_VER v1.0
        RUN echo $CONT_IMG_VER

        -> É basicamente uma maneira de pegar argumentos na hora de 
        buildar uma nova imagem.
        @@ docker image build --build-arg CONT_IMG_VER=v2.0 Dockerfile 
            -> Nesse caso, quando buildarmos esse Dockerfile, o
            ARGUMENTO ARG vai ser o valor que passamos como PARAMETRO
            na linha de comando.

    HELTHCHECK:
        HEALTHCHECK --interval=5m --timeout=3s \
        CMD curl -f http://localhost/ || exit 1
            -> Aqui ele vai chekcar a "saude" do meu container.
            -> No intervalo e com timeout especificos.

    MULTI-STAGE:
        FROM golang:alpine AS buildando
        ADD . /src
        RUN cd /src && go build -o opa

        FROM alpine
        WORKDIR /app
        COPY --from=buildando /src/opa /app
        ENTRYPOINT ["./opa"]

        -> Basicamente é uma forma de pegar o resultado de um build
        e usar em outro build. Algo semelhante a um pipeline.

=======================================================================================
=======================================================================================

AULA 16 / 17:
    Tageando uma imagem
    @@ docker image tag <id_imagem> OU <nome_imagem> nome_user_dockehub/nome_imagem:version
        -> A ideia desse comando é conseguirmos jogar as nossa imagens lá
        para o docker hub.
    
    @@ docker push nome_user_dockehub/nome_imagem:version
        -> Estando logado com o dockerhub, essa é a forma de jogarmos
        nossa imagem chamada "nome_user_dockehub/nome_imagem:version"
        lá no dockerhub.
        -> Isso é basicamente igual ao github.

    @@ docker image rm nome_user_dockehub/nome_imagem:version
    @@ docker container run -d "nome_user_dockehub/nome_imagem:version"
        -> Como apagamos a imagem que nós tageamos, não temos
        ela cacheada nem na nossa máquina mais.
        -> Dessa forma, precisamos puxar ela lá do dockerhub.
        -> Ao executarmos o segundo comando acima, o docker vai
        puxar lá do dockerhub!


=======================================================================================
=======================================================================================
