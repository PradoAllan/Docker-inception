# Alguns comandos que eu preciso testar vistos no Curso do linuxTips.

1- Criar um Dockerfile, isto é, uma imagem customizada de algum serviço:
    @@ mkdir <nome_dir>
    @@ cd <nome_dir>
    @@ vim Dockerfile
        -> A ideia do dockerfile é criar uma imagem 
        "customizada"
        -> Exemplo de dockerfile no arquivo Dockerfile
    @@ docker image build -t <nome_imagem>:1.0 .
        -> Dessa forma, vamos buildar a imagem expecífica
        -> a FLAG -t indica que vamos colocar uma tag
        nessa imagem.
        -> Depois do nome colocamos a versão. (boas praticas)
    @@ docker container run -d <nome_imagem>
        -> Depois de buildar a imagem, vamos SUBIR o container
        com essa imagem.
    @@ docker container ls
        -> Para pegarmos o id do container
    @@ docker container stats <id_container>
        -> Para vermos as estatísticas do container em execução

2- Como estressar um container que está rodando:
    @@ docker container run -d <nome_imagem>
        -> Estamos subindo um container
    @@ docker container ls
        -> Veremos qual o id / nome do container que subimos
    @@ docker container stats <id_container> OU <nome_container>
        -> Em outro terminal, vamos ver as estatisticas do container
        que queremos testar.
    @@ docker container exec -ti <id_container> OU <nome_container> bash
        -> Vamos acessar o ENTRYPOINT do container especifico.
        -> Ao acessar esse container estamos "dentro" do espaço
        ISOLADO daquele container.
    @@ apt-get update && apt-get install stress
        -> Instalando o comando stress, que vamos usar para teste
    @@ stress --help
    @@ stress --cpu 1 --vm-bytes 128M --vm 1
        -> Com esse comando, vamos estressar o container.
        -> Vamos usar 100% da CPU, 128M da memória

3- Como especificar quando de recurso um container vai ter:
    @@ docker image ls
        -> Vamos decidir qual imagem vamos usar nesse container
    @@ docker container run -d --cpus 0.5 -m 128M <nome_imagem>
        -> COM A FLAG -d: estamos dizendo que esse container rodara em segundo plano
        -> COM A FLAG --cpus: estamos dizendo que esse container terá 0.5 de uma CPU
        50%
        -> COM A FLAG -m: estamos dizendo que esse container terá 128M de memoria 
    @@ docker container inspect <id_container> OU <nome_container>
        -> Vamos ver as informaçoes sobre este container especifico.
        -> Podemos ver quanto de CPU e memoria esse container tem acesso
    @@ docker container stats <id_container> OU <nome_container>
        -> Vamos conferir quanto desse recurso o container está consumindo 
        de fato.

4- Como criar um container que usa um VOLUME do tipo BIND:
    @@ mkdir /volume/bind
        -> Aqui vamos criar um dir para servir como base para montarmos
        um container.
    @@ docker container run -ti --mount type=bind,src=/opt/testebind,dst=/testebind <nome_imagem>
        -> Aqui estamos subindo um container que está sendo montado na pasta
        /testebind e está usando como base o volume /opt/testebind.
        -> A imagem usada é a <nome_imagem>
        -> O type é para indicar o tipo de volume que vamos usar na montagem
        desse container.
    @@ cd testebind
    @@ touch teste1
    @@ exit
        -> para matarmos o container atual
    @@ docker container run -ti --mount type=bind,src=/opt/testebind,dst=/testebind <nome_imagem>
        -> para subir outro container usando o VOLUME BIND anterior
    @@ cd testebind
        -> veremos que o teste1 ainda estará lá
        -> podemos modificar o arquivo, criar outro, apagar.
        -> Caso o container caia, basta subir outro usando o mesmo VOLUME
        que não perdermos as informações e dados que tinhamos.

5- Como criar um VOLUME do tipo VOLUME e subir um container com ele:
    @@ docker volume ls
        -> para vermos os volumes existentes
    @@ docker volume create <nome_volume>
        -> usamos para criar um novo volume com um nome especifico
    @@ docker volume inspect <nome_volume>
        -> usamos para inspecionar o volume. Isto é, veremos várias
        informações sobre aquele volume
    @@ docker container run -ti --mount type=volume,src=<nome_volume>,dst=<nome_dir> <nome_imagem>
        -> O ti é apenas para indicar que termos o terminal ativo como
        ENTRYPOINT
        -> a FLAG --mount: indica que montaremos o container de uma
        forma diferente. Isto é, usando um volume, no caso.
        -> o SRC=: indica qual volume voce quer usar ao subir esse container
        -> o DST=: indica a pasta que teremos acesso as infos e dados
        -> por ultimo, o nome da imagem que queremos
    IMPORTANTE:
        -> AO RODARMOS O DOCKER CONTAINER RUN COM A FLAG -ti,
        ESTAMOS APENAS INDICANDO QUE TEREMOS UM TERMINAL COMO 
        ENTRYPOINT PARA ESTE CONTAINER ESPECIFICO. 
        -> PODEMOS USAR A FLAG -d PARA RODARMOS ELE EM SEGUNDO
        PLANO.

6- Desafio AULA 05 day 02:
    Criar um volume
    @@ docker volume create desafio
        -> criei um novo volume chamado desafio
    Subir dois containeres de postgrees usando esse volume criado
    @@ docker container run -d -p 5432:5432 --name pgsql1 --mount type=volume,src=desafio,dst=/desafio
    -e POSTGRESQL_USER=docker
    -e POSTGRESQL_PASS=docker
    -e POSTGRESQL_DB=docker kamui/postgresql
        -> Tive problema com essa imagem do postgresql.
        -> disse que eu preciso ter acesso ao dockerhub para usa-la
        -> minha solução estava 90% correta. Apenas 1 detalhe errado:

    SOLUÇÃO CORRETA:
    @@ docker container run -d -p 5432:5432 --name pgsql1 --mount type=volume,src=desafio,dst=/data
    -e POSTGRESQL_USER=docker
    -e POSTGRESQL_PASS=docker
    -e POSTGRESQL_DB=docker kamui/postgresql
        -> Basicamente, errei apenas no nome da pasta dst=..
        -> não sei se o meu funcionaria tbm, acretido que não. Mas não pude testar...

7- Criando um novo DOCKERFILE e BUILDANDO com uma TAG:
    Basicamente, um Dockerfile é composto por algumas camadas que vão ser responsáveis
    por criar uma imagem feita por nós. Isto é, podemos fazer toda a configuração da
    maneira que acharmos melhor.
    Exemplo de Dockerfile que usa um Webserver apache e roda em cima de um debian:
        FROM debian

        RUN apt-get update && apt-get install -y apache2 && apt-get clean
        ENV APACHE_LOCK_DIR="/var/lock"
        ENV APACHE_PID_FILE="/var/run/apache2.pid"
        ENV APACHE_RUN_USER="www-data"
        ENV APACHE_RUN_GROUP="www-data"
        ENV APACHE_LOG_DIR="/var/log/apache2"

        LABEL description="Webserver"

        VOLUME /var/www/html/
        EXPOSE 80

        ENTRYPOINT ["/usr/sbin/apachectl"]
        CMD ["-D", "FOREGROUND"]
    -> O Dockerfile acima se encontra na pasta dockerfiles.

    Para usar esse Dockerfile como base de um container, precisamos fazer o seguinte:

    @@ docker image build -t <nome_image> .
        -> Vamos buildar o Dockerfile
        -> O build vai ter o nome X de acordo com a FLAG -t. 
        -> O '.' indica que estamos nos referindo ao Dockerfile no repositorio
        atual

    @@ docker image ls
        -> Dessa forma vemos que temos uma nova imagem já buildada com o nome
        <nome_image>
        -> Agora sempre que quisermos subir um novo container usando essa imagem
        como base, é só usarmos o <nome_image> como base.


8- Subindo um novo CONTAINER e DANDO ACESSO AO HOST pela PORTA do CONTAINER:
    "Sabemos que, quando criamos um novo container, este é totalmente ISOLADO
    do host e dos outros containers. Dessa forma, precisamos 'liberar' o 
    acesso ao container através das portas de rede."

    Para tal, fazemos da seguinte forma:
    @@ docker container run -d -p 8080:80 <nome_image>
        -> Dessa forma, estamos subindo um novo container usando uma imagem já buildada
        -> Estamos dizendo que ela vai rodar em segundo plano "-d"
        -> Estamos dizendo, também, que o container está mapeando a porta 80 do container
        para a porta 8080 do host.
        -> Vale ressaltar que a porta 80 já foi exposta no Dockerfile
    
    Para acessarmos esse container, acesse:
        http://localhost:8080/
            -> localhost é do pc que está hospedando o container.
            -> 8080 é a porta que está mapeada para o container.
    
    OBS: Uma parte importante para termos acesso ao container em execução é: o -d 8080:80
        -> "Execute a imagem X como um novo container, e mapeie a porta 
        80 do container para a porta 8080 do meu computador."

    @@ docker container run -d -p 8080:80 --name webserver <nome_imagem>
        -> Podemos executar com a FLAG --name para darmos um nome ao 
        container em execução.
        -> Dessa forma fica mais fácil a identificação do mesmo.
