############################################################################
                                DOCKERFILE
############################################################################

FROM python:3.10-alpine
    -> Estamos dizendo que essa nova imagem usará, como base, o python:3.10 alpine.
    Que é uma versão minimalista e segura do python usando o alpine-linux.

WORKDIR /code
    -> Informa que o diretório onde nosso container vai ser "executado"
    isto é, onde vai ser executado todos os outros comandos.
    -> Em termos gerais, onde vai ser o diretório de trabalho do container.

ENV FLASK_APP=app.py
ENV FLASK_RUN_HOST=0.0.0.0
    -> Duas variáveis de ambiente que, provavelmente, o flask usa.
    -> A segunda, indica que o flask escutará todas as interfaces de rede.
    Que é importante para ele escutar fora do container.

RUN apk add --no-cache gcc musl-dev linux-headers
    -> Instala pacotes necessários para que o python rode de forma correta.
    Isto é, pacotes python que dependem de C/C++.

COPY requirements.txt requirements.txt
    -> Copia o arquivo requirements.txt do host para dentro do diretório /code
    do container.
    -> Copia para o diretório /code pois foi definido anteriormente com o WORKDIR.

RUN pip install -r requirements.txt
    -> Instala as dependencias que o container vai precisar para funcionar.

EXPOSE 5000
    -> Informa que o container escutará na porta 5000 dele.
    -> É apenas uma instrução declarativa, com fins de documentação.
    -> Só vai ser exposta na hora do build da imagem. Seja com o Docker-compose
    ou Kubernets.

COPY . .
    -> Copia TODOS os arquivos do diretório atual do HOST para o diretório
    /code do container.

CMD ["flask", "run", "--debug"]
    -> Comando padrão que será executado toda vez que o container subir.
    -> No caso, executa o app flask em modo debug. (não indicado para prod)

############################################################################
                                DOCKER COMPOSE
############################################################################

services:
    -> Onde definimos os servicos (containers) que teremos na nossa aplicacao.

  web:
    -> Primeiro, teremos um servico web.
    build: .
        -> O build dele será feito através de um DOCKERFILE que está presente dentro do
        diretório atual.

    ports:
      - "8000:5000"
        -> Estamos dizendo que o container que rodará o servico web vai expor a porta
        5000 dele para a porta 8000 do host.
        -> Então, o HOST conseguirá acessar o container com o servico através da porta
        8000 dele.
        -> Indicamos isso dentro do DOCKERFILE no expose. Mas não é obrigatório...
  
  redis:
    -> Segundo servico que teremos nessa nossa aplicacao. Chamado Redis.
    image: "redis:alpine"
        -> Estamos dizendo que ele vai usar uma imagem alpine do redis.
        -> Que é uma imagem já existente. Provavelmente disponivel no docker hub.
        -> Mas podemos ter um Registry dessa imagem lá tbm. 

    -> Como esse servico redis não expoe suas portas (do container) para fora. 
    isto é, para o host, ele estará apenas liberado para a rede interna do Docker
    compose.
    -> Então, só conseguimos acessar esse servico a partir da rede interna do 
    docker compose.

############################################################################
                                COMMANDS
############################################################################

Após criamos o nosso docker compose, podemos executá-lo usando o seguinte
comando:
    @@ docker compose up
        -> Ao digitarmos esse comando dentro do dir onde o docker-compose.yaml
        se encontra, o orquestrador COMPOSE vai fazer todo o trabalho para nós.
        -> Ele vai buildar o que for preciso
        -> Baixar as imagens necessárias
        -> Criar todos os volumes
        -> Fazer toda a configuração da NETWORK
        -> Expor todas as portas do container
        -> De forma geral, ele vai deixar tudo pronto para uso!

Uma vez noo ar, podemos encerrar nossa STACK (aplicação) de duas formas:
    @@ docker compose down
        -> Em outro terminal, digitamos o comando acima.
        -> Ele vai "desligar" os serviços

    @@ CTRL + C
        -> No terminal onde o serviço está rodando
        -> Estamos "Matando" o processo específico

Podemos rodar o docker compose up com a flag de DETACH, isto é, Para
rodar em "Segundo plano":
    @@ docker compose up -d
        -> Vai rodar o arquivo compose.yaml do dir atual
        -> Vai subir os servicos necessários
        -> E vai subir em "segundo plano", isto é, em detach mode

############################################################################
                                COMPOSE WATCH
############################################################################

...
  web:
    build: .
    ports:
      - "8000:5000"
    develop:
      watch:                    -> Compose Watch
        - action: sync          -> Dizendo que ele vai sincronizar
          path: .               -> Qual caminho do HOST ele vai monitorar
          target: /code         -> Dir final dos arquivos modificados
...

O Develop.watch (compose watch) no Docker compose:
    -> Funciona como um monitor de arquivos
    -> Fica observando uma ou mais pastas
    -> Ao detectar que algum arquivo foi modificado, ele:
        -> Sincroniaza a nova versão automaticamente com o container
        -> Não reinicia o container
        -> Sem rebuild
        -> Sem "docker compose down" e "up"
        -> De forma rápida e leve
    
Isso é ótimo pois permite que possamos modificar um arquivo, no host,
e ver a modificação automaticamente no nosso container. Isto tudo
sem prerder tempo dando rebuild no serviço!

############################################################################
                                INCLUDE
############################################################################

Em aplicações grandes, ter apenas um arquivo COMPOSE pode dificultar o
entendimento/manutenção dos containers/services. Para diminuir essa
dificuldade podemos segregar, isto é, dividir, nossa aplicação em mais
de um arquivo .yaml. Facilitando, assim, a manutenção do mesmo.

Para fazermos isso, precisamos de uma forma para compilar todos services/
containers após essa divisão. A forma que fazemos isso é através do
"include" dentro de um compose.yaml que vai compilar tudo.

Por ex:
    Se temos um compose.yaml que possui dois serivces, podemos dividir
    um deles em outro arquivo e inclui-lo no compose.yaml.

    Arquivo infra.yaml:
        redis:
        image: "redis:alpine"
    -> Aqui temos um service em outro arquivo.

    Arquivo compose.yaml:
        include:
        - infra.yaml
            -> Incluindo o outro service declarado em outro arquivo .yaml

        services:
        web:
            build: .
            ports:
            - "8000:5000"
            develop:
            watch:
                - action: sync
                path: .
                target: /code
    -> Aqui temos o compose.yaml "Base". Que será usado na hora de subir
    a aplicação.
    -> Nele, apenas incluimos o outro service necessário para a nossa
    aplicação.
